// Start topology output
hoc_stdout("Insert_Path/output/64T.csv")
topology()
forall{
	printf("%s\n",secname())
	printf("%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%.16f,%f,%f\n",nseg,L,diam,Ra,cm,dt,st.del,st.dur,st.amp,tfinal,v(0.5),area(0.5),parent_connection(),n3d())
}
hoc_stdout()
// End topology output
// Start topologyList output
hoc_stdout("Insert_Path/output/64TL.csv")
MyTopology()
hoc_stdout()
// End topologyList output
// Start mechanisms output
objref mt,ms,fn,pp
strdef s,ss,mname
mt = new MechanismType(0)
fn = new File()
fn.wopen("Insert_Path/output/64MDL.csv")
forall{
	fn.printf("#%s\n",secname())
	if (ismembrane("pas")){
		fn.printf("g_pas = %f\n",g_pas)
		fn.printf("e_pas = %f\n",e_pas)
	}
	for i=0, mt.count()-1 {
		mt.select(i)
		mt.selected(mname)
		if (ismembrane(mname)){
			ms = new MechanismStandard(mname,-1)
			for j=0, ms.count()-1 {
				k = ms.name(s, j)
				sprint(ss,"temp=%s",s)
				execute(ss)
				fn.printf("%s = %f\n",s,temp)
			}
		}
	}
}
fn.close()
// End mechanisms output

// Start mechanisms output
objref mt,ms,fn,pp
strdef s,ss,mname
mt = new MechanismType(0)
fn = new File()
fn.wopen("Insert_Path/output/64GLOBAL.csv")
forall{
	fn.printf("#%s\n",secname())
	for i=0, mt.count()-1 {
		mt.select(i)
		mt.selected(mname)
		if (ismembrane(mname)){
			ms = new MechanismStandard(mname,0)
			for j=0, ms.count()-1 {
				k = ms.name(s, j)
				sprint(ss,"temp=%s",s)
				execute(ss)
				fn.printf("%s = %f\n",s,temp)
			}
		}
	}
	fn.printf("END_OF_SECTION\n")
}
fn.close()
// End mechanisms output

// Start point processess mechanisms output
fn = new File()
fn.wopen("Insert_Path/output/64PP.csv")
forall{
	fn.printf("#%s\n",secname())
	mt = new MechanismType(1)
	mt.select("IClamp")
	for (pp = mt.pp_begin(); object_id(pp) != 0; pp = mt.pp_next()) {
		x = pp.get_loc()
		del1 = pp.del
		dur1 = pp.dur
		amp1 = pp.amp
		fn.printf("IClamp,%g, %g, %g, %g, ", x, del1, dur1, amp1)
		pop_section()
	}
	fn.printf("\n")
}
fn.close()
// End point processess mechanisms output
hoc_stdout("Insert_Path/output/64F.csv")
MyPrintMatrix()
hoc_stdout()
// End Fmatrix
